#include <iostream>
#include <unordered_map>
#include <queue>
#include <string>
#include <vector> 
#include <fstream>
#include <locale>
#include <codecvt>

using namespace std;

struct node {
    char ch;
    int freq;
    node *left;
    node *right;
};

// struct usada na fila de prioridade(priority_queue)
struct comp {
    bool operator()(node* l, node* r) {
        return l->freq > r->freq;
    }
};

// funcao para alocar um novo nodo na memoria
node *create_node(char c, int frequency, node *left, node *right) {
    node *p = new node;
    p->ch = c;
    p->freq = frequency;
    p->left = left;
    p->right = right;

    return p;
}

void encode(node *root, string str, unordered_map<char, string> &huffcode) {
    if (!root) return;

    if (!root->left && !root->right) {
        huffcode[root->ch] = str;
    }

    encode(root->left, str + "0", huffcode);
    encode(root->right, str + "1", huffcode);
}

void decode(node *root, int &top_index, string str) {
    if (!root) return;

    if (!root->left && !root->right) {
        cout << root->ch;
        return;
    }
    top_index++;

    if (str[top_index] == '0') decode(root->left, top_index, str);
    else if (str[top_index] == '1') decode(root->right, top_index, str);
}

void buildHuffTree(const wstring &content) {
    unordered_map<char, int> freq;
    for (wchar_t wc : content) {
        char ch = static_cast<char>(wc); // assumindo que o conteudo é ASCII
        freq[ch]++;
    }

    int teste = 0; // contador somente para fins de teste 
    cout << "Frequencia de caracteres: \n";
    for (auto ch : freq) { 
        if (ch.first == ' ') cout << "SPACE: " << ch.second << endl;
        else if (ch.first == '\n') cout << "\\n: " << ch.second << endl;
        else cout << ch.first << ": " << ch.second << endl;
        teste += ch.second; // esta inconsistente, ver pq
    }
    cout << teste << endl << endl;

    priority_queue<node*, vector<node*>, comp> pq; 

    for (auto pair : freq) {
        pq.push(create_node(pair.first, pair.second, nullptr, nullptr));
    }

    while (pq.size() != 1) {
        node *left = pq.top();
        pq.pop();
        node *right = pq.top();
        pq.pop();

        int soma = left->freq + right->freq;
        pq.push(create_node('\0', soma, left, right));
    }

    node *root = pq.top();
    unordered_map<char, string> huffCode;
    encode(root, "", huffCode);

    cout << "Codigos binarios da arvore criada: \n";
    for (auto pair : huffCode) {
        if (pair.first == ' ') cout << "SPACE: " << pair.second << endl;
        else if (pair.first == '\n') cout << "\\n: " << pair.second << endl;
        else cout << pair.first << ": " << pair.second << endl;
    }
}

wstring readUnicodeFile(const string &filename) {
    ifstream file(filename, ios::binary);
    if (!file.is_open()) {
        cerr << "Erro ao abrir o arquivo!" << endl;
        return L"";
    }

    // criar um conversor para UTF-8
    wstring_convert<codecvt_utf8_utf16<wchar_t>> converter;

    // ler o conteúdo do arquivo em uma string
    string content((istreambuf_iterator<char>(file)), istreambuf_iterator<char>());

    // converter a string UTF-8 para wstring
    wstring wide_content = converter.from_bytes(content);

    file.close();
    return wide_content;
}

int main() {
    string filename = "../clarissa.txt";
    wstring content = readUnicodeFile(filename);
    
    if (content.empty()) {
        return 1;
    }

    buildHuffTree(content);

    return 0;
}
